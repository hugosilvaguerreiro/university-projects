var utils = {

	// Returns a new 2D array with dimensions rows by cols. All cells
	// will initially contain the value given by initVal.
	create2DArray: function (rows, cols, initVal) {
		var res = new Array(rows);
		for (var row = 0; row < rows; row++) {
			res[row] = new Array(cols);
			for (var col = 0; col < cols; col++) {
				res[row][col] = initVal;
			}
		}
		return res;
	},

	// A Python-like mod.
	mod: function (n, p) {
		if (n < 0) {
			return p + n % p;
		} else {
			return n % p;
		}
	},

	createMap: function (rows, cols, seed) {
		var _seed = Math.random()
		noise.seed(_seed);
		var heightsMap = this.create2DArray(rows, cols, 0.0);

		for (var x = 0; x < rows; x++) {
			for (var y = 0; y < cols; y++) {
				heightsMap[x][y] = Math.min(Math.round(Math.abs(noise.perlin2(x / 100, y / 100)) * 30), 14);
				//console.log(heightsMap[x][y]);
			}
		}

		return heightsMap;

	},

	rgb: function (r, g, b) {
		for (var i = 0; i < arguments.length; i++) {
			if (arguments[i] < 0 || arguments[i] > 255) {
				throw new RangeError("Color components must be in the range [0, 255].");
			}
		}
		return {
			r: r,
			g: g,
			b: b
		};
	},

	generateGradient: function (baseColor, targetColor, nColors) {
		var distanceR = targetColor.r - baseColor.r;
		var distanceG = targetColor.g - baseColor.g;
		var distanceB = targetColor.b - baseColor.b;

		//console.log(distanceR + " , " + distanceG/10 + " , " + distanceB)


		var colors = new Array(nColors);
		var newColor = this.rgb(baseColor.r, baseColor.g, baseColor.b);
		for (var i = 0; i < nColors; i++) {
			colors[i] = this.rgb(newColor.r, newColor.g, newColor.b);
			newColor.r += Math.round(distanceR / nColors);
			newColor.g += Math.round(distanceG / nColors);
			newColor.b += Math.round(distanceB / nColors);
		}
		return colors;
	},

	getRandomInt: function (min, max) {
		min = Math.ceil(min);
		max = Math.floor(max);
		return Math.floor(Math.random() * (max - min + 1)) + min;
	},

	copyObj: function (src) {
		return Object.assign({}, src);
	},


	blend_colors: function (color1, color2, percentage) {


		if (percentage > 1 || percentage < 0)
			throw new error('percentage must be between 0 and 1');

		color1 = [color1.r, color1.g, color1.b];
		color2 = [color2.r, color2.g, color2.b];


		//console.log('valid: c1 => ' + color1 + ', c2 => ' + color2);
		var color3 = [
			(1 - percentage) * color1[0] + percentage * color2[0],
			(1 - percentage) * color1[1] + percentage * color2[1],
			(1 - percentage) * color1[2] + percentage * color2[2]
		];

		//console.log('c3 => [' + color3.join(', ') + ']');

		var res = this.rgb(color3[0], color3[1], color3[2]);
		// return hex
		return res;
	},



	generateWindModel: function (rows, cols, direction, intensity, heightMap) {
        
        var replace_movement = [
            [[0,1],[0,1],[1,0]],
            [[-1,0],[-1,0],[1,0]],
            [[-1,0],[0,-1],[0,-1]]
        ]

        step = 0.125
        
        // Maps the direction from the 0-100 range to 0-64 meaning there can exist 64 different wind directions
        direction = Math.round((direction*16)/25); 

		base_model = [
			[0.0, 0.0, 1.0],
			[0.0, 0.0, 1.0],
			[0.0, 0.0, 1.0]
        ]
        var to_replace = [0,1];
        var replacement = [2,2];

        for(var i = 0; i < direction; i++) {
            // The model is generated by rotating around the base model values  based on the wind direction.
            // A value of 0 in the direction means that the wind is blowing from east to west and a value of
            // 50 means that it is blowing from east to west.
            // For each tree we generate a 3x3 matrix where it specifies the way the wind is blowing on that point
            // As an example, imagine a tree in the position x, y and that the direction is 0. The matrix generated for
            // that location would be the one in the base_model but including the intensity parameter and taking the height into account.

            if(base_model[to_replace[0]][to_replace[1]] <= 0) {
                base_model[to_replace[0]][to_replace[1]] = 0;
                base_model[replacement[0]][replacement[1]] = 1; 
                
                var tmp_x = to_replace[0];
                var tmp_y = to_replace[1];
                
                to_replace[0] += replace_movement[tmp_x][tmp_y][0];
                to_replace[1] += replace_movement[tmp_x][tmp_y][1];

                tmp_x = replacement[0];
                tmp_y = replacement[1];

                replacement[0] += replace_movement[tmp_x][tmp_y][0];
                replacement[1] += replace_movement[tmp_x][tmp_y][1];


            }

            base_model[to_replace[0]][to_replace[1]] -= step;
            base_model[replacement[0]][replacement[1]] += step;


        }
        for(var i = 0; i < 3; i++) {
            for(var j = 0; j < 3; j++) {
                if(i === 1 && j === 1) {
                    base_model[i][j] = 1;
                    continue;
                }
                if(base_model[i][j] === 0) {
                        base_model[i][j] = 1 - intensity;
                } else {
                    //base_model[i][j] -= 0.01
                }
                
            }
        }

		windModel = utils.create2DArray(rows, cols, base_model);
		return windModel;
    }
    
};